
// SlkParse.cpp - generated by the SLK parser generator 

#include "SlkParse.h"

static slk_size_t Production[] = {0

,3,11,12,24 ,3,12,13,20 ,11,13,1,25,2,3,14,1,4,2,3,26 
,15,13,1,25,2,3,5,27,2,6,14,1,4,2,3,26 
,10,13,1,28,2,3,18,1,4,2,3 ,2,14,15 ,2,14,16 
,2,14,17 ,3,15,29,19 ,5,16,7,15,21,8 ,5,17,7,16,22,8 
,3,18,13,23 ,2,19,2 ,2,19,9 ,3,20,13,20 ,1,20 
,3,21,15,21 ,2,21,30 ,3,22,16,22 ,2,22,31 ,3,23,13,23 
,2,23,32 
,0};

static slk_size_t Production_row[] = {0

,1,5,9,21,37,48,51,54,57,61,67,73,77,80,83,87
,89,93,96,100,103,107
,0};

static slk_size_t Parse[] = {

0,0,1,6,2,17,9,13,24,15,6,18,17,9,14,19,20,23,16
,10,11,12,25,0,0,0,0,0,0,0,0,0
};

static slk_size_t Parse_row[] = {0

,1,3,16,1,4,12,13,20,5,8,3,8,21
,0};

static slk_size_t Conflict[] = {

0,0,0,26,7,21,27,22,0,8,0,7,5,3,0,0,4,0,3
,0,3
};

static slk_size_t Conflict_row[] = {0

,1,2,3,3,11
,0};

#define GET_CONDITIONAL_PRODUCTION( symbol )  0 
#define get_predicted_entry( a,b,c,d,e )  0 

#define START_SYMBOL 11
#define END_OF_SLK_INPUT_ 10
#define START_STATE 0
#define START_CONFLICT 23
#define END_CONFLICT 28
#define START_ACTION 24
#define END_ACTION 33
#define TOTAL_CONFLICTS 5
#define PARSE_STACK_SIZE 512
#define SLK_PUSH(symbol,stack,top) if ( top > stack ) *--top = symbol
#define SLK_POP(top)   (*top ? *top++ : 0)

#define peek(self,a)            self.peek(a)
#define get(self)               self.get()
#define mismatch(self,a,b)      self.mismatch(a,b)
#define no_entry(self,a,b,c)    self.no_entry(a,b,c)
#define input_left(self)        self.input_left()
#define message(self,a)         self.message(a)
#define predict(self,a)         self.predict(a)
#define reduce(self,a)          self.reduce(a)
#define state(self,a)           self.state(a)
#define execute(self,a)         self.execute(a)

#define NOT_A_SYMBOL       0
#define NONTERMINAL_SYMBOL 1
#define TERMINAL_SYMBOL    2
#define ACTION_SYMBOL      3

int SlkGetSymbolType ( slk_size_t symbol )
{
   int   symbol_type = NOT_A_SYMBOL;

   if ( symbol >= START_ACTION  &&  symbol < END_ACTION ) {
       symbol_type = ACTION_SYMBOL;
   } else if ( symbol >= START_SYMBOL ) {
       symbol_type = NONTERMINAL_SYMBOL;
   } else if ( symbol > 0 ) {
       symbol_type = TERMINAL_SYMBOL;
   }
   return  symbol_type;
}

slk_size_t *SlkGetProductionArray ( slk_size_t   production_number )
{
    return   &Production [ Production_row [production_number] ];
}

int SlkIsNonterminal ( slk_size_t symbol )
{
   return ( symbol >= START_SYMBOL  &&  symbol < START_ACTION );
}

int SlkIsTerminal ( slk_size_t symbol )
{
   return ( symbol > 0  &&  symbol < START_SYMBOL );
}

int SlkIsAction ( slk_size_t symbol )
{
   return ( symbol >= START_ACTION  &&  symbol < END_ACTION );
}

slk_size_t SlkGetProduction ( slk_size_t   conflict_number,
                              SlkToken   &tokens ) 
{
    slk_size_t  entry = 0;
    int         index, level;

    if ( conflict_number <= TOTAL_CONFLICTS ) {
        entry = conflict_number + (START_CONFLICT -1);
        level = 1;
        while ( entry >= START_CONFLICT ) {
            index = Conflict_row [entry - (START_CONFLICT -1)];
            index += peek ( tokens, level );
            entry = Conflict [ index ];
            ++level;
        }
    }

    return  entry;
}

void SlkParse ( SlkAction  &action, 
                SlkToken   &tokens, 
                SlkError   &error, 
                slk_size_t  start_symbol ) 
{
 register
 slk_size_t  *top, *production;
 slk_size_t   production_number, entry, symbol, token, new_token;
 int          production_length, index, level;
 slk_size_t   stack [ PARSE_STACK_SIZE ];

 top = stack + (PARSE_STACK_SIZE-1);
 *top = 0;
 if ( ! start_symbol ) {
     start_symbol = START_SYMBOL;
 }
 SLK_PUSH ( start_symbol, stack, top );
 token = get(tokens);
 new_token = token;

 for ( symbol = SLK_POP ( top );  symbol;  ) {

     if ( symbol >= START_ACTION ) {
         execute ( action, (symbol-(START_ACTION-1)) );

     } else if ( symbol >= START_SYMBOL ) {
         entry = 0;
         level = 1;
         production_number = GET_CONDITIONAL_PRODUCTION ( symbol );
         if ( production_number ) {
             entry = get_predicted_entry ( tokens,
                                           production_number, token,
                                           level, 1 );
         }
         if ( ! entry ) {
             index = Parse_row [symbol - (START_SYMBOL-1)];
             index += token;
             entry = Parse [ index ];
         }
         while ( entry >= START_CONFLICT ) {
             index = Conflict_row [entry - (START_CONFLICT -1)];
             index += peek (tokens, level);
             entry = Conflict [ index ];
             ++level;
         }
         if ( entry ) {
             production = &Production [ Production_row [entry] ];
             production_length = *production - 1;
             if ( *++production == symbol ) {
                 predict ( action, entry );
                 production += production_length;
                 for (;  production_length-- > 0;  --production ) {
                     SLK_PUSH ( *production, stack, top );
                 }
             } else {
                 new_token = no_entry ( error, symbol, token, level-1 );
             }
         } else {
             new_token = no_entry ( error, symbol, token, level-1 );
         }
     } else if ( symbol > 0 ) {
         if ( symbol == token ) {
             token = get(tokens);
             new_token = token;
         } else {
             new_token = mismatch ( error, symbol, token );
         }
     }
     if ( token != new_token ) {
         if ( new_token ) {
             token = new_token;
         }
         if ( token != END_OF_SLK_INPUT_ ) {
             continue;
         }
     }
     symbol = SLK_POP ( top );
 }
 if ( token != END_OF_SLK_INPUT_ ) {
     input_left ( error );
 }
}

